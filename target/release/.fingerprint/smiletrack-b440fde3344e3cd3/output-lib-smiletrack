{"$message_type":"diagnostic","message":"failed to resolve: use of unresolved module or unlinked crate `num_traits`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/detection.rs","byte_start":175,"byte_end":185,"line_start":10,"line_end":10,"column_start":5,"column_end":15,"is_primary":true,"text":[{"text":"use num_traits::cast::ToPrimitive;","highlight_start":5,"highlight_end":15}],"label":"use of unresolved module or unlinked crate `num_traits`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you wanted to use a crate named `num_traits`, use `cargo add num_traits` to add it to your `Cargo.toml`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of unresolved module or unlinked crate `num_traits`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/detection.rs:10:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse num_traits::cast::ToPrimitive;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of unresolved module or unlinked crate `num_traits`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: if you wanted to use a crate named `num_traits`, use `cargo add num_traits` to add it to your `Cargo.toml`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `to_f32` found for type `f64` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs","byte_start":4225,"byte_end":4231,"line_start":108,"line_end":108,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"    fn to_f32(&self) -> Option<f32> {","highlight_start":8,"highlight_end":14}],"label":"the method is available for `f64` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":4878,"byte_end":4889,"line_start":152,"line_end":152,"column_start":26,"column_end":37,"is_primary":false,"text":[{"text":"                    1 => conf_scores.get(i as i64).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":26,"highlight_end":37}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":4922,"byte_end":4928,"line_start":152,"line_end":152,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"                    1 => conf_scores.get(i as i64).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use anyhow::Result;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use num_traits::cast::ToPrimitive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"there is a method `to_i32` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":4922,"byte_end":4928,"line_start":152,"line_end":152,"column_start":70,"column_end":76,"is_primary":true,"text":[{"text":"                    1 => conf_scores.get(i as i64).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":70,"highlight_end":76}],"label":null,"suggested_replacement":"to_i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `to_f32` found for type `f64` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/detection.rs:152:70\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m152\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    1 => conf_scores.get(i as i64).double_value(&[]).to_f32().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs:108:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn to_f32(&self) -> Option<f32> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe method is available for `f64` here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[38;5;10m+ use num_traits::cast::ToPrimitive;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `to_i32` with a similar name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m152\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                    1 => conf_scores.get(i as i64).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;9mto_f32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m152\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                    1 => conf_scores.get(i as i64).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;10mto_i32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `to_f32` found for type `f64` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs","byte_start":4225,"byte_end":4231,"line_start":108,"line_end":108,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"    fn to_f32(&self) -> Option<f32> {","highlight_start":8,"highlight_end":14}],"label":"the method is available for `f64` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":4984,"byte_end":4997,"line_start":153,"line_end":153,"column_start":38,"column_end":51,"is_primary":false,"text":[{"text":"                    2 => conf_scores.get(i as i64).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":38,"highlight_end":51}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":4972,"byte_end":4983,"line_start":153,"line_end":153,"column_start":26,"column_end":37,"is_primary":false,"text":[{"text":"                    2 => conf_scores.get(i as i64).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":26,"highlight_end":37}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":5023,"byte_end":5029,"line_start":153,"line_end":153,"column_start":77,"column_end":83,"is_primary":true,"text":[{"text":"                    2 => conf_scores.get(i as i64).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":77,"highlight_end":83}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use anyhow::Result;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use num_traits::cast::ToPrimitive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"there is a method `to_i32` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":5023,"byte_end":5029,"line_start":153,"line_end":153,"column_start":77,"column_end":83,"is_primary":true,"text":[{"text":"                    2 => conf_scores.get(i as i64).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":77,"highlight_end":83}],"label":null,"suggested_replacement":"to_i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `to_f32` found for type `f64` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/detection.rs:153:77\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m153\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    2 => conf_scores.get(i as i64).get(0).double_value(&[]).to_f32().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs:108:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn to_f32(&self) -> Option<f32> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe method is available for `f64` here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[38;5;10m+ use num_traits::cast::ToPrimitive;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `to_i32` with a similar name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m153\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                    2 => conf_scores.get(i as i64).get(0).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;9mto_f32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m153\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                    2 => conf_scores.get(i as i64).get(0).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;10mto_i32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `to_f32` found for type `f64` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs","byte_start":4225,"byte_end":4231,"line_start":108,"line_end":108,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"    fn to_f32(&self) -> Option<f32> {","highlight_start":8,"highlight_end":14}],"label":"the method is available for `f64` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":5818,"byte_end":5837,"line_start":171,"line_end":171,"column_start":26,"column_end":45,"is_primary":false,"text":[{"text":"                    1 => conf_scores_sigmoid.get(i).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":26,"highlight_end":45}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":5863,"byte_end":5869,"line_start":171,"line_end":171,"column_start":71,"column_end":77,"is_primary":true,"text":[{"text":"                    1 => conf_scores_sigmoid.get(i).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":71,"highlight_end":77}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use anyhow::Result;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use num_traits::cast::ToPrimitive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"there is a method `to_i32` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":5863,"byte_end":5869,"line_start":171,"line_end":171,"column_start":71,"column_end":77,"is_primary":true,"text":[{"text":"                    1 => conf_scores_sigmoid.get(i).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":71,"highlight_end":77}],"label":null,"suggested_replacement":"to_i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `to_f32` found for type `f64` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/detection.rs:171:71\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m171\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    1 => conf_scores_sigmoid.get(i).double_value(&[]).to_f32().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs:108:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn to_f32(&self) -> Option<f32> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe method is available for `f64` here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[38;5;10m+ use num_traits::cast::ToPrimitive;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `to_i32` with a similar name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m171\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                    1 => conf_scores_sigmoid.get(i).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;9mto_f32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m171\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                    1 => conf_scores_sigmoid.get(i).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;10mto_i32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `to_f32` found for type `f64` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs","byte_start":4225,"byte_end":4231,"line_start":108,"line_end":108,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"    fn to_f32(&self) -> Option<f32> {","highlight_start":8,"highlight_end":14}],"label":"the method is available for `f64` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":5933,"byte_end":5939,"line_start":172,"line_end":172,"column_start":46,"column_end":52,"is_primary":false,"text":[{"text":"                    2 => conf_scores_sigmoid.get(i).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":46,"highlight_end":52}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":5913,"byte_end":5932,"line_start":172,"line_end":172,"column_start":26,"column_end":45,"is_primary":false,"text":[{"text":"                    2 => conf_scores_sigmoid.get(i).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":26,"highlight_end":45}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":5965,"byte_end":5971,"line_start":172,"line_end":172,"column_start":78,"column_end":84,"is_primary":true,"text":[{"text":"                    2 => conf_scores_sigmoid.get(i).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":78,"highlight_end":84}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use anyhow::Result;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use num_traits::cast::ToPrimitive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"there is a method `to_i32` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":5965,"byte_end":5971,"line_start":172,"line_end":172,"column_start":78,"column_end":84,"is_primary":true,"text":[{"text":"                    2 => conf_scores_sigmoid.get(i).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":78,"highlight_end":84}],"label":null,"suggested_replacement":"to_i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `to_f32` found for type `f64` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/detection.rs:172:78\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m172\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    2 => conf_scores_sigmoid.get(i).get(0).double_value(&[]).to_f32().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs:108:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn to_f32(&self) -> Option<f32> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe method is available for `f64` here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[38;5;10m+ use num_traits::cast::ToPrimitive;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `to_i32` with a similar name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m172\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                    2 => conf_scores_sigmoid.get(i).get(0).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;9mto_f32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m172\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                    2 => conf_scores_sigmoid.get(i).get(0).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;10mto_i32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `to_f32` found for type `f64` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs","byte_start":4225,"byte_end":4231,"line_start":108,"line_end":108,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"    fn to_f32(&self) -> Option<f32> {","highlight_start":8,"highlight_end":14}],"label":"the method is available for `f64` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":6536,"byte_end":6554,"line_start":187,"line_end":187,"column_start":30,"column_end":48,"is_primary":false,"text":[{"text":"                        1 => cls_scores_sigmoid.get(i).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":30,"highlight_end":48}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":6580,"byte_end":6586,"line_start":187,"line_end":187,"column_start":74,"column_end":80,"is_primary":true,"text":[{"text":"                        1 => cls_scores_sigmoid.get(i).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":74,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use anyhow::Result;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use num_traits::cast::ToPrimitive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"there is a method `to_i32` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":6580,"byte_end":6586,"line_start":187,"line_end":187,"column_start":74,"column_end":80,"is_primary":true,"text":[{"text":"                        1 => cls_scores_sigmoid.get(i).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":74,"highlight_end":80}],"label":null,"suggested_replacement":"to_i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `to_f32` found for type `f64` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/detection.rs:187:74\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        1 => cls_scores_sigmoid.get(i).double_value(&[]).to_f32().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------------\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs:108:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn to_f32(&self) -> Option<f32> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe method is available for `f64` here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[38;5;10m+ use num_traits::cast::ToPrimitive;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `to_i32` with a similar name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                        1 => cls_scores_sigmoid.get(i).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;9mto_f32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                        1 => cls_scores_sigmoid.get(i).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;10mto_i32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `to_f32` found for type `f64` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs","byte_start":4225,"byte_end":4231,"line_start":108,"line_end":108,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"    fn to_f32(&self) -> Option<f32> {","highlight_start":8,"highlight_end":14}],"label":"the method is available for `f64` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":6653,"byte_end":6659,"line_start":188,"line_end":188,"column_start":49,"column_end":55,"is_primary":false,"text":[{"text":"                        2 => cls_scores_sigmoid.get(i).get(c).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":49,"highlight_end":55}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":6634,"byte_end":6652,"line_start":188,"line_end":188,"column_start":30,"column_end":48,"is_primary":false,"text":[{"text":"                        2 => cls_scores_sigmoid.get(i).get(c).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":30,"highlight_end":48}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":6685,"byte_end":6691,"line_start":188,"line_end":188,"column_start":81,"column_end":87,"is_primary":true,"text":[{"text":"                        2 => cls_scores_sigmoid.get(i).get(c).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":81,"highlight_end":87}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use anyhow::Result;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use num_traits::cast::ToPrimitive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"there is a method `to_i32` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":6685,"byte_end":6691,"line_start":188,"line_end":188,"column_start":81,"column_end":87,"is_primary":true,"text":[{"text":"                        2 => cls_scores_sigmoid.get(i).get(c).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":81,"highlight_end":87}],"label":null,"suggested_replacement":"to_i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `to_f32` found for type `f64` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/detection.rs:188:81\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m188\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        2 => cls_scores_sigmoid.get(i).get(c).double_value(&[]).to_f32().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs:108:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn to_f32(&self) -> Option<f32> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe method is available for `f64` here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[38;5;10m+ use num_traits::cast::ToPrimitive;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `to_i32` with a similar name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m188\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                        2 => cls_scores_sigmoid.get(i).get(c).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;9mto_f32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m188\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                        2 => cls_scores_sigmoid.get(i).get(c).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;10mto_i32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `to_f32` found for type `f64` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs","byte_start":4225,"byte_end":4231,"line_start":108,"line_end":108,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"    fn to_f32(&self) -> Option<f32> {","highlight_start":8,"highlight_end":14}],"label":"the method is available for `f64` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":6765,"byte_end":6771,"line_start":189,"line_end":189,"column_start":56,"column_end":62,"is_primary":false,"text":[{"text":"                        3 => cls_scores_sigmoid.get(i).get(c).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":56,"highlight_end":62}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":6758,"byte_end":6764,"line_start":189,"line_end":189,"column_start":49,"column_end":55,"is_primary":false,"text":[{"text":"                        3 => cls_scores_sigmoid.get(i).get(c).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":49,"highlight_end":55}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":6739,"byte_end":6757,"line_start":189,"line_end":189,"column_start":30,"column_end":48,"is_primary":false,"text":[{"text":"                        3 => cls_scores_sigmoid.get(i).get(c).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":30,"highlight_end":48}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":6797,"byte_end":6803,"line_start":189,"line_end":189,"column_start":88,"column_end":94,"is_primary":true,"text":[{"text":"                        3 => cls_scores_sigmoid.get(i).get(c).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":88,"highlight_end":94}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use anyhow::Result;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use num_traits::cast::ToPrimitive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"there is a method `to_i32` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":6797,"byte_end":6803,"line_start":189,"line_end":189,"column_start":88,"column_end":94,"is_primary":true,"text":[{"text":"                        3 => cls_scores_sigmoid.get(i).get(c).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":88,"highlight_end":94}],"label":null,"suggested_replacement":"to_i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `to_f32` found for type `f64` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/detection.rs:189:88\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m189\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   3 => cls_scores_sigmoid.get(i).get(c).get(0).double_value(&[]).to_f32().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs:108:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn to_f32(&self) -> Option<f32> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe method is available for `f64` here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[38;5;10m+ use num_traits::cast::ToPrimitive;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `to_i32` with a similar name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m189\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                        3 => cls_scores_sigmoid.get(i).get(c).get(0).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;9mto_f32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m189\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                        3 => cls_scores_sigmoid.get(i).get(c).get(0).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;10mto_i32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `to_f32` found for type `f64` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs","byte_start":4225,"byte_end":4231,"line_start":108,"line_end":108,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"    fn to_f32(&self) -> Option<f32> {","highlight_start":8,"highlight_end":14}],"label":"the method is available for `f64` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":7858,"byte_end":7864,"line_start":217,"line_end":217,"column_start":32,"column_end":38,"is_primary":false,"text":[{"text":"                    2 => boxes.get(i).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":32,"highlight_end":38}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":7852,"byte_end":7857,"line_start":217,"line_end":217,"column_start":26,"column_end":31,"is_primary":false,"text":[{"text":"                    2 => boxes.get(i).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":26,"highlight_end":31}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":7890,"byte_end":7896,"line_start":217,"line_end":217,"column_start":64,"column_end":70,"is_primary":true,"text":[{"text":"                    2 => boxes.get(i).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":64,"highlight_end":70}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use anyhow::Result;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use num_traits::cast::ToPrimitive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"there is a method `to_i32` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":7890,"byte_end":7896,"line_start":217,"line_end":217,"column_start":64,"column_end":70,"is_primary":true,"text":[{"text":"                    2 => boxes.get(i).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":64,"highlight_end":70}],"label":null,"suggested_replacement":"to_i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `to_f32` found for type `f64` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/detection.rs:217:64\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m217\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    2 => boxes.get(i).get(0).double_value(&[]).to_f32().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs:108:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn to_f32(&self) -> Option<f32> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe method is available for `f64` here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[38;5;10m+ use num_traits::cast::ToPrimitive;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `to_i32` with a similar name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m217\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                    2 => boxes.get(i).get(0).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;9mto_f32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m217\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                    2 => boxes.get(i).get(0).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;10mto_i32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `to_f32` found for type `f64` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs","byte_start":4225,"byte_end":4231,"line_start":108,"line_end":108,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"    fn to_f32(&self) -> Option<f32> {","highlight_start":8,"highlight_end":14}],"label":"the method is available for `f64` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":7953,"byte_end":7959,"line_start":218,"line_end":218,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"                    3 => boxes.get(i).get(0).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":39,"highlight_end":45}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":7946,"byte_end":7952,"line_start":218,"line_end":218,"column_start":32,"column_end":38,"is_primary":false,"text":[{"text":"                    3 => boxes.get(i).get(0).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":32,"highlight_end":38}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":7940,"byte_end":7945,"line_start":218,"line_end":218,"column_start":26,"column_end":31,"is_primary":false,"text":[{"text":"                    3 => boxes.get(i).get(0).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":26,"highlight_end":31}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":7985,"byte_end":7991,"line_start":218,"line_end":218,"column_start":71,"column_end":77,"is_primary":true,"text":[{"text":"                    3 => boxes.get(i).get(0).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":71,"highlight_end":77}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use anyhow::Result;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use num_traits::cast::ToPrimitive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"there is a method `to_i32` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":7985,"byte_end":7991,"line_start":218,"line_end":218,"column_start":71,"column_end":77,"is_primary":true,"text":[{"text":"                    3 => boxes.get(i).get(0).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":71,"highlight_end":77}],"label":null,"suggested_replacement":"to_i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `to_f32` found for type `f64` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/detection.rs:218:71\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m218\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    3 => boxes.get(i).get(0).get(0).double_value(&[]).to_f32().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs:108:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn to_f32(&self) -> Option<f32> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe method is available for `f64` here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[38;5;10m+ use num_traits::cast::ToPrimitive;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `to_i32` with a similar name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m218\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                    3 => boxes.get(i).get(0).get(0).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;9mto_f32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m218\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                    3 => boxes.get(i).get(0).get(0).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;10mto_i32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `to_f32` found for type `f64` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs","byte_start":4225,"byte_end":4231,"line_start":108,"line_end":108,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"    fn to_f32(&self) -> Option<f32> {","highlight_start":8,"highlight_end":14}],"label":"the method is available for `f64` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":8158,"byte_end":8164,"line_start":223,"line_end":223,"column_start":32,"column_end":38,"is_primary":false,"text":[{"text":"                    2 => boxes.get(i).get(1).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":32,"highlight_end":38}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":8152,"byte_end":8157,"line_start":223,"line_end":223,"column_start":26,"column_end":31,"is_primary":false,"text":[{"text":"                    2 => boxes.get(i).get(1).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":26,"highlight_end":31}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":8190,"byte_end":8196,"line_start":223,"line_end":223,"column_start":64,"column_end":70,"is_primary":true,"text":[{"text":"                    2 => boxes.get(i).get(1).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":64,"highlight_end":70}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use anyhow::Result;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use num_traits::cast::ToPrimitive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"there is a method `to_i32` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":8190,"byte_end":8196,"line_start":223,"line_end":223,"column_start":64,"column_end":70,"is_primary":true,"text":[{"text":"                    2 => boxes.get(i).get(1).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":64,"highlight_end":70}],"label":null,"suggested_replacement":"to_i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `to_f32` found for type `f64` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/detection.rs:223:64\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m223\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    2 => boxes.get(i).get(1).double_value(&[]).to_f32().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs:108:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn to_f32(&self) -> Option<f32> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe method is available for `f64` here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[38;5;10m+ use num_traits::cast::ToPrimitive;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `to_i32` with a similar name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m223\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                    2 => boxes.get(i).get(1).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;9mto_f32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m223\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                    2 => boxes.get(i).get(1).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;10mto_i32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `to_f32` found for type `f64` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs","byte_start":4225,"byte_end":4231,"line_start":108,"line_end":108,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"    fn to_f32(&self) -> Option<f32> {","highlight_start":8,"highlight_end":14}],"label":"the method is available for `f64` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":8253,"byte_end":8259,"line_start":224,"line_end":224,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"                    3 => boxes.get(i).get(1).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":39,"highlight_end":45}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":8246,"byte_end":8252,"line_start":224,"line_end":224,"column_start":32,"column_end":38,"is_primary":false,"text":[{"text":"                    3 => boxes.get(i).get(1).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":32,"highlight_end":38}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":8240,"byte_end":8245,"line_start":224,"line_end":224,"column_start":26,"column_end":31,"is_primary":false,"text":[{"text":"                    3 => boxes.get(i).get(1).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":26,"highlight_end":31}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":8285,"byte_end":8291,"line_start":224,"line_end":224,"column_start":71,"column_end":77,"is_primary":true,"text":[{"text":"                    3 => boxes.get(i).get(1).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":71,"highlight_end":77}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use anyhow::Result;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use num_traits::cast::ToPrimitive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"there is a method `to_i32` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":8285,"byte_end":8291,"line_start":224,"line_end":224,"column_start":71,"column_end":77,"is_primary":true,"text":[{"text":"                    3 => boxes.get(i).get(1).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":71,"highlight_end":77}],"label":null,"suggested_replacement":"to_i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `to_f32` found for type `f64` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/detection.rs:224:71\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m224\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    3 => boxes.get(i).get(1).get(0).double_value(&[]).to_f32().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs:108:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn to_f32(&self) -> Option<f32> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe method is available for `f64` here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[38;5;10m+ use num_traits::cast::ToPrimitive;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `to_i32` with a similar name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m224\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                    3 => boxes.get(i).get(1).get(0).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;9mto_f32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m224\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                    3 => boxes.get(i).get(1).get(0).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;10mto_i32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `to_f32` found for type `f64` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs","byte_start":4225,"byte_end":4231,"line_start":108,"line_end":108,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"    fn to_f32(&self) -> Option<f32> {","highlight_start":8,"highlight_end":14}],"label":"the method is available for `f64` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":8458,"byte_end":8464,"line_start":229,"line_end":229,"column_start":32,"column_end":38,"is_primary":false,"text":[{"text":"                    2 => boxes.get(i).get(2).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":32,"highlight_end":38}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":8452,"byte_end":8457,"line_start":229,"line_end":229,"column_start":26,"column_end":31,"is_primary":false,"text":[{"text":"                    2 => boxes.get(i).get(2).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":26,"highlight_end":31}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":8490,"byte_end":8496,"line_start":229,"line_end":229,"column_start":64,"column_end":70,"is_primary":true,"text":[{"text":"                    2 => boxes.get(i).get(2).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":64,"highlight_end":70}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use anyhow::Result;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use num_traits::cast::ToPrimitive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"there is a method `to_i32` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":8490,"byte_end":8496,"line_start":229,"line_end":229,"column_start":64,"column_end":70,"is_primary":true,"text":[{"text":"                    2 => boxes.get(i).get(2).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":64,"highlight_end":70}],"label":null,"suggested_replacement":"to_i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `to_f32` found for type `f64` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/detection.rs:229:64\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m229\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    2 => boxes.get(i).get(2).double_value(&[]).to_f32().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs:108:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn to_f32(&self) -> Option<f32> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe method is available for `f64` here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[38;5;10m+ use num_traits::cast::ToPrimitive;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `to_i32` with a similar name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m229\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                    2 => boxes.get(i).get(2).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;9mto_f32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m229\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                    2 => boxes.get(i).get(2).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;10mto_i32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `to_f32` found for type `f64` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs","byte_start":4225,"byte_end":4231,"line_start":108,"line_end":108,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"    fn to_f32(&self) -> Option<f32> {","highlight_start":8,"highlight_end":14}],"label":"the method is available for `f64` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":8553,"byte_end":8559,"line_start":230,"line_end":230,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"                    3 => boxes.get(i).get(2).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":39,"highlight_end":45}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":8546,"byte_end":8552,"line_start":230,"line_end":230,"column_start":32,"column_end":38,"is_primary":false,"text":[{"text":"                    3 => boxes.get(i).get(2).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":32,"highlight_end":38}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":8540,"byte_end":8545,"line_start":230,"line_end":230,"column_start":26,"column_end":31,"is_primary":false,"text":[{"text":"                    3 => boxes.get(i).get(2).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":26,"highlight_end":31}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":8585,"byte_end":8591,"line_start":230,"line_end":230,"column_start":71,"column_end":77,"is_primary":true,"text":[{"text":"                    3 => boxes.get(i).get(2).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":71,"highlight_end":77}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use anyhow::Result;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use num_traits::cast::ToPrimitive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"there is a method `to_i32` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":8585,"byte_end":8591,"line_start":230,"line_end":230,"column_start":71,"column_end":77,"is_primary":true,"text":[{"text":"                    3 => boxes.get(i).get(2).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":71,"highlight_end":77}],"label":null,"suggested_replacement":"to_i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `to_f32` found for type `f64` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/detection.rs:230:71\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m230\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    3 => boxes.get(i).get(2).get(0).double_value(&[]).to_f32().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs:108:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn to_f32(&self) -> Option<f32> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe method is available for `f64` here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[38;5;10m+ use num_traits::cast::ToPrimitive;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `to_i32` with a similar name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m230\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                    3 => boxes.get(i).get(2).get(0).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;9mto_f32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m230\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                    3 => boxes.get(i).get(2).get(0).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;10mto_i32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `to_f32` found for type `f64` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs","byte_start":4225,"byte_end":4231,"line_start":108,"line_end":108,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"    fn to_f32(&self) -> Option<f32> {","highlight_start":8,"highlight_end":14}],"label":"the method is available for `f64` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":8758,"byte_end":8764,"line_start":235,"line_end":235,"column_start":32,"column_end":38,"is_primary":false,"text":[{"text":"                    2 => boxes.get(i).get(3).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":32,"highlight_end":38}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":8752,"byte_end":8757,"line_start":235,"line_end":235,"column_start":26,"column_end":31,"is_primary":false,"text":[{"text":"                    2 => boxes.get(i).get(3).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":26,"highlight_end":31}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":8790,"byte_end":8796,"line_start":235,"line_end":235,"column_start":64,"column_end":70,"is_primary":true,"text":[{"text":"                    2 => boxes.get(i).get(3).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":64,"highlight_end":70}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use anyhow::Result;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use num_traits::cast::ToPrimitive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"there is a method `to_i32` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":8790,"byte_end":8796,"line_start":235,"line_end":235,"column_start":64,"column_end":70,"is_primary":true,"text":[{"text":"                    2 => boxes.get(i).get(3).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":64,"highlight_end":70}],"label":null,"suggested_replacement":"to_i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `to_f32` found for type `f64` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/detection.rs:235:64\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m235\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    2 => boxes.get(i).get(3).double_value(&[]).to_f32().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs:108:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn to_f32(&self) -> Option<f32> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe method is available for `f64` here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[38;5;10m+ use num_traits::cast::ToPrimitive;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `to_i32` with a similar name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m235\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                    2 => boxes.get(i).get(3).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;9mto_f32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m235\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                    2 => boxes.get(i).get(3).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;10mto_i32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `to_f32` found for type `f64` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs","byte_start":4225,"byte_end":4231,"line_start":108,"line_end":108,"column_start":8,"column_end":14,"is_primary":false,"text":[{"text":"    fn to_f32(&self) -> Option<f32> {","highlight_start":8,"highlight_end":14}],"label":"the method is available for `f64` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":8853,"byte_end":8859,"line_start":236,"line_end":236,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"                    3 => boxes.get(i).get(3).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":39,"highlight_end":45}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":8846,"byte_end":8852,"line_start":236,"line_end":236,"column_start":32,"column_end":38,"is_primary":false,"text":[{"text":"                    3 => boxes.get(i).get(3).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":32,"highlight_end":38}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":8840,"byte_end":8845,"line_start":236,"line_end":236,"column_start":26,"column_end":31,"is_primary":false,"text":[{"text":"                    3 => boxes.get(i).get(3).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":26,"highlight_end":31}],"label":"method `to_f32` is available on `&tch::Tensor`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/detection.rs","byte_start":8885,"byte_end":8891,"line_start":236,"line_end":236,"column_start":71,"column_end":77,"is_primary":true,"text":[{"text":"                    3 => boxes.get(i).get(3).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":71,"highlight_end":77}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use anyhow::Result;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use num_traits::cast::ToPrimitive;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"there is a method `to_i32` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/detection.rs","byte_start":8885,"byte_end":8891,"line_start":236,"line_end":236,"column_start":71,"column_end":77,"is_primary":true,"text":[{"text":"                    3 => boxes.get(i).get(3).get(0).double_value(&[]).to_f32().unwrap_or(0.0),","highlight_start":71,"highlight_end":77}],"label":null,"suggested_replacement":"to_i32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `to_f32` found for type `f64` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/detection.rs:236:71\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m236\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    3 => boxes.get(i).get(3).get(0).double_value(&[]).to_f32().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `to_f32` is available on `&tch::Tensor`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/witsarut/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/cast.rs:108:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m108\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn to_f32(&self) -> Option<f32> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe method is available for `f64` here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is in scope\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: trait `ToPrimitive` which provides `to_f32` is implemented but not in scope; perhaps you want to import it\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[38;5;10m+ use num_traits::cast::ToPrimitive;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `to_i32` with a similar name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m236\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m                    3 => boxes.get(i).get(3).get(0).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;9mto_f32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m236\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m                    3 => boxes.get(i).get(3).get(0).double_value(&[]).\u001b[0m\u001b[0m\u001b[38;5;10mto_i32\u001b[0m\u001b[0m().unwrap_or(0.0),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 16 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 16 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0433, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0433, E0599.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0433`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0433`.\u001b[0m\n"}
